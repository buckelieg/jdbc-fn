/*
 * Copyright 2016- Anatoly Kutyakov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package buckelieg.jdbc;

import buckelieg.jdbc.fn.TryFunction;

import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;

/**
 * An abstraction for DML (INSERT/UPDATE/DELETE) statements
 * <br/>Returns affected rows by this query
 * <br/>If this is a batch query then affected rows are summed
 */
@SuppressWarnings("unchecked")
@ParametersAreNonnullByDefault
public interface Update extends Query<Update> {

  /**
   * Executes this DML query returning affected row count
   * <br/>If this query represents a batch then affected rows are summed for all batches
   *
   * @return affected rows count
   */
  @Nonnull
  Long execute();

  /**
   * Executes an update query providing generated results
   * <br/>Autogenerated keys columns are accessible via their indices inside {@code generatedValuesHandler}
   * <br/>Example:
   * <pre>{@code
   * List<Long> list = db.execute(rs -> rs.getLong(1)).collect(Collectors.toList())
   * }</pre>
   *
   * @param generatedValuesMapper generated values <code>ResultSet</code> mapper function
   * @return a {@link List} of mapped generated results
   * @throws NullPointerException if generatedValuesHandler or valueMapper is null
   * @see java.sql.Connection#prepareStatement(String, int)
   */
  @Nonnull
  <T> List<T> execute(TryFunction<ValueReader, T, SQLException> generatedValuesMapper);

  /**
   * Executes an update query providing generated results
   * <br/>Autogenerated keys columns are accessible via their names inside <code>generatedValuesHandler</code>
   * <br/>Example:
   * <pre>{@code
   * List<Long> list = db.execute(rs -> rs.getLong(1), "id").collect(Collectors.toList())
   * }</pre>
   *
   * @param generatedValuesMapper generated values <code>ResultSet</code> mapper function
   * @param colNames              column names with generated keys
   * @return a {@link List} of mapped generated results
   * @throws NullPointerException     if colNames or generatedValuesHandler or valueMapper is null
   * @throws IllegalArgumentException if colNames is empty
   * @see java.sql.Connection#prepareStatement(String, String[])
   */
  @Nonnull
  <T> List<T> execute(TryFunction<ValueReader, T, SQLException> generatedValuesMapper, String... colNames);

  /**
   * Executes an update query providing generated results
   * <br/>Autogenerated keys columns are accessible via their indices inside <code>generatedValuesHandler</code>
   * <br/>Example:
   * <pre>{@code
   * List<Long> list = db.execute(rs -> rs.getLong(1), 1).collect(Collectors.toList())
   * }</pre>
   *
   * @param generatedValuesMapper generated values <code>ResultSet</code> mapper function
   * @param colIndices            indices of the columns with generated keys
   * @return a {@link List} of mapped generated results
   * @throws NullPointerException     if colIndices or generatedValuesHandler or valueMapper is null
   * @throws IllegalArgumentException if colIndices is empty
   * @see java.sql.Connection#prepareStatement(String, int[])
   */
  @Nonnull
  <T> List<T> execute(TryFunction<ValueReader, T, SQLException> generatedValuesMapper, int... colIndices);

  /**
   * Tells this update will be a large update
   *
   * @return update query abstraction
   * @see PreparedStatement#executeLargeUpdate()
   */
  Update large(boolean isLarge);

  /**
   * Tells DB to use batch (if possible)
   * <br/>Value of <code>1</code> denotes that no batching is used
   * <br/>Default value of <code>batchSize</code> is <code>1</code>
   * <br/>Value less than <code>1</code> are silently ignored
   *
   * @param batchSize the size of batch to use (must be greater or equal to 1)
   * @return update query abstraction
   * @see DatabaseMetaData#supportsBatchUpdates()
   */
  Update batch(int batchSize);

}
