/*
 * Copyright 2024- Anatoly Kutyakov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package buckelieg.jdbc;

import buckelieg.jdbc.fn.TryBiConsumer;
import buckelieg.jdbc.fn.TryBiFunction;
import buckelieg.jdbc.fn.TryConsumer;
import buckelieg.jdbc.fn.TryFunction;

import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import java.sql.Connection;
import java.util.function.*;

import static java.sql.Connection.*;

/**
 * Represents a database <code>transaction</code>
 */
@ParametersAreNonnullByDefault
public interface Transaction {

  /**
   * Transaction isolation level
   *
   * @see Connection#TRANSACTION_READ_UNCOMMITTED
   * @see Connection#TRANSACTION_READ_COMMITTED
   * @see Connection#TRANSACTION_REPEATABLE_READ
   * @see Connection#TRANSACTION_SERIALIZABLE
   */
  enum Isolation {

	/**
	 * Level of {@link Connection#TRANSACTION_READ_UNCOMMITTED}
	 */
	READ_UNCOMMITTED(TRANSACTION_READ_UNCOMMITTED),

	/**
	 * Level of {@link  Connection#TRANSACTION_READ_COMMITTED}
	 */
	READ_COMMITTED(TRANSACTION_READ_COMMITTED),

	/**
	 * Level of {@link  Connection#TRANSACTION_REPEATABLE_READ}
	 */
	REPEATABLE_READ(TRANSACTION_REPEATABLE_READ),

	/**
	 * Level of {@link  Connection#TRANSACTION_SERIALIZABLE}
	 */
	SERIALIZABLE(TRANSACTION_SERIALIZABLE);

	final int level;

	Isolation(int level) {
	  this.level = level;
	}

	public static Isolation valueOf(int level) {
	  switch (level) {
		case TRANSACTION_READ_COMMITTED:
		  return READ_COMMITTED;
		case TRANSACTION_REPEATABLE_READ:
		  return REPEATABLE_READ;
		case TRANSACTION_READ_UNCOMMITTED:
		  return READ_UNCOMMITTED;
		case TRANSACTION_SERIALIZABLE:
		  return SERIALIZABLE;
		default:
		  throw new SQLRuntimeException("Unsupported transaction isolation level: " + level);
	  }
	}
  }

  /**
   * Represents context of a transaction
   */
  interface Context {

	/**
	 * Obtains a name of a user which this transaction is executed under
	 *
	 * @return a username
	 */
	String username();

	/**
	 * Provides a transaction identifier (which is generated by transaction id provider)
	 *
	 * @return a current transaction identifier
	 * @see DB.Builder#withTransactionIdProvider(Supplier)
	 */
	String transactionId();

  }

  /**
   * Executes this transaction with an optional result<br/>
   * Transaction is not committed in case of any errors<br/>
   * If {@link Transaction#onRollback(Consumer)} is set - then it is invoked
   *
   * @param transaction a transaction logic function
   * @param <T>         result type
   * @return an arbitrary result
   * @throws NullPointerException if <code>transaction</code> is null
   * @see Transaction#onCommit(Runnable)
   * @see Transaction#onRollback(Consumer)
   */
  @Nonnull
  default <T> T execute(TryFunction<Session, T, ? extends Exception> transaction) {
	if (null == transaction) throw new NullPointerException("Transaction function must be provided");
	return execute((session, context) -> transaction.apply(session));
  }

  /**
   * Executes this transaction with an optional result<br/>
   * Transaction is not committed in case of any errors<br/>
   * If {@link Transaction#onRollback(Consumer)} is set - then it is invoked<br/>
   * <br/><table>
   * <caption>A {@code transaction} function parameters</caption>
   * <tr>
   * <th>Argument</th>
   * <th>Type</th>
   * <th>Description</th>
   * </tr>
   * <tr>
   * <td>session</td>
   * <td>{@linkplain Session}</td>
   * <td>a session object for any queries to produce</td>
   * </tr>
   * <tr>
   * <td>context</td>
   * <td>{@linkplain Context}</td>
   * <td>a transaction context object</td>
   * </tr>
   * </table>
   *
   * @param transaction a transaction logic function
   * @param <T>         result type
   * @return an arbitrary result
   * @throws NullPointerException if <code>transaction</code> is null
   * @see Transaction#onCommit(Runnable)
   * @see Transaction#onRollback(Consumer)
   */
  @Nonnull
  <T> T execute(TryBiFunction<Session, Context, T, ? extends Exception> transaction);

  /**
   * Executes this transaction without any results<br/>
   * Transaction is not committed in case of any errors
   *
   * @param transaction a transaction logic function
   * @throws NullPointerException if <code>transaction</code> is null
   * @see Transaction#run(TryBiConsumer)
   */
  default void run(TryConsumer<Session, ? extends Exception> transaction) {
	if (null == transaction) throw new NullPointerException("Transaction function must be provided");
	run(((session, context) -> transaction.accept(session)));
  }

  /**
   * Executes this transaction without any results<br/>
   * Transaction is not committed in case of any errors<br/>
   * <br/><table>
   * <caption>A {@code transaction} function parameters</caption>
   * <tr>
   * <th>Argument</th>
   * <th>Type</th>
   * <th>Description</th>
   * </tr>
   * <tr>
   * <td>session</td>
   * <td>{@linkplain Session}</td>
   * <td>a session object for any queries to produce</td>
   * </tr>
   * <tr>
   * <td>context</td>
   * <td>{@linkplain Context}</td>
   * <td>a transaction context object</td>
   * </tr>
   * </table>
   * <p>
   * <br/>Example:
   * <pre>{@code
   * db.transaction().run((session, context) -> session
   * 	.select("SELECT id FROM users WHERE username = ?", context.username()).execute(rs -> rs.getLong(1))
   * 	.forEach(id -> session.update("INSERT INTO log(uid, txid) VALUES(?, ?)", id, context.transactionId()).execute())
   * )
   * }</pre>
   * </p>
   *
   * @param transaction a transaction logic function
   */
  default void run(TryBiConsumer<Session, Context, ? extends Exception> transaction) {
	if (null == transaction) throw new NullPointerException("Transaction function must be provided");
	execute((session, context) -> {
	  transaction.accept(session, context);
	  return null;
	});
  }

  /**
   * Registers handler that is run BEFORE transaction commit is done.<br/>
   * If this method returns <code>true</code> - then transaction is committed and results are returned.<br/>
   * Whenever handler returns <code>false</code> - the transaction is rolled back and no results are returned.
   *
   * @param beforeCommitHandler a function that is run before transaction commits
   * @return a transaction instance
   * @throws NullPointerException if <code>beforeCommitHandler</code> is null
   */
  @Nonnull
  Transaction onBeforeCommit(Predicate<Context> beforeCommitHandler);

  /**
   * Registers handler that is run BEFORE transaction commit is done.<br/>
   * If this method returns <code>true</code> - then transaction is committed and results are returned.<br/>
   * Whenever handler returns <code>false</code> - the transaction is rolled back and no results are returned.
   *
   * @param beforeCommitHandler a function that is run before transaction commits
   * @return a transaction instance
   * @throws NullPointerException if <code>beforeCommitHandler</code> is null
   */
  @Nonnull
  default Transaction onBeforeCommit(BooleanSupplier beforeCommitHandler) {
	if (null == beforeCommitHandler) throw new NullPointerException("Transaction before commit handler must be provided");
	return onBeforeCommit(context -> beforeCommitHandler.getAsBoolean());
  }

  /**
   * Sets transaction commit event handler<br/>
   * Invoked (in the same thread) <code>after</code> this transaction is committed
   *
   * @param commitHandler transaction commit handler
   * @return a transaction instance
   * @throws NullPointerException if <code>commitHandler</code> is null
   */
  @Nonnull
  default Transaction onCommit(Runnable commitHandler) {
	if (null == commitHandler) throw new NullPointerException("Transaction commit handler must be provided");
	return onCommit(context -> commitHandler.run());
  }

  /**
   * Sets transaction commit event handler<br/>
   * Invoked (in the same thread) <code>after</code> this transaction is committed
   *
   * @param commitHandler transaction commit handler
   * @return a transaction instance
   * @throws NullPointerException if <code>commitHandler</code> is null
   */
  @Nonnull
  Transaction onCommit(Consumer<Context> commitHandler);

  /**
   * Sets transaction rollback handler<br/>
   * invoked (in the same thread) if exception is occurred (after transaction is rolled back)
   *
   * @param rollbackHandler transaction rollback handler
   * @return a transaction instance
   * @throws NullPointerException if <code>rollbackHandler</code> is null
   * @see #onRollback(BiConsumer)
   */
  @Nonnull
  default Transaction onRollback(Consumer<? super Throwable> rollbackHandler) {
	if (null == rollbackHandler) throw new NullPointerException("Rollback handler must be provided");
	return onRollback((exception, context) -> rollbackHandler.accept(exception));
  }

  /**
   * A handler which will be invoked whenever transaction rollbacks<br/>
   * <br/><table>
   * <caption>A {@code rollbackHandler} function parameters</caption>
   * <tr>
   * <th>Argument</th>
   * <th>Type</th>
   * <th>Description</th>
   * </tr>
   * <tr>
   * <td>session</td>
   * <td>{@linkplain Throwable}</td>
   * <td>an error object</td>
   * </tr>
   * <tr>
   * <td>context</td>
   * <td>{@linkplain Context}</td>
   * <td>a transaction context object</td>
   * </tr>
   * </table>
   *
   * @param rollbackHandler transaction rollback handler
   * @return a transaction instance
   * @throws NullPointerException if <code>rollbackHandler</code> is null
   */
  Transaction onRollback(BiConsumer<? super Throwable, Context> rollbackHandler);

  /**
   * Sets transaction isolation level
   *
   * @param level transaction isolation level
   * @return a transaction instance
   * @throws NullPointerException if <code>level</code> is null
   * @see Isolation
   */
  @Nonnull
  Transaction isolation(Isolation level);

}
